# Exerc√≠cio 01 - Sistema de Monitoramento de M√©tricas üü°

**N√≠vel:** Intermedi√°rio  
**Tempo Estimado:** 60-90 minutos  
**Objetivo:** Desenvolver sistema completo de monitoramento cont√≠nuo de m√©tricas

## Contexto

Voc√™ foi contratado por uma empresa de tecnologia em crescimento para desenvolver um sistema de monitoramento que acompanhe m√©tricas de teste em tempo real para m√∫ltiplos projetos. O sistema deve coletar dados automaticamente, detectar anomalias, e alertar a equipe quando crit√©rios cr√≠ticos est√£o sendo violados.

A empresa tem 3 projetos em desenvolvimento simult√¢neo com diferentes caracter√≠sticas e necessidades de monitoramento. O sistema deve ser flex√≠vel para acomodar diferentes tipos de projeto e extens√≠vel para futuras m√©tricas.

## Requisitos do Sistema

### RF01 - Coleta Autom√°tica de M√©tricas
Implementar sistema que simule coleta autom√°tica de m√©tricas:
- **Cobertura de c√≥digo** (linha, branch, fun√ß√£o)
- **Densidade de defeitos** por m√≥dulo
- **Tempo m√©dio de detec√ß√£o** de defeitos
- **Taxa de descoberta** de defeitos (defeitos/dia)
- **Performance de testes** (tempo de execu√ß√£o)

### RF02 - Detec√ß√£o de Anomalias
Identificar automaticamente:
- **Degrada√ß√£o s√∫bita** (queda >10% em m√©tricas cr√≠ticas)
- **Tend√™ncias negativas** (decl√≠nio consistente por 3+ medi√ß√µes)
- **Viola√ß√£o de thresholds** cr√≠ticos
- **Padr√µes irregulares** (variabilidade excessiva)

### RF03 - Sistema de Alertas
Implementar alertas em tr√™s n√≠veis:
- üî¥ **CR√çTICO:** Viola√ß√£o de crit√©rios obrigat√≥rios  
- üü° **ATEN√á√ÉO:** Tend√™ncias preocupantes
- üîµ **INFO:** Marcos atingidos ou melhorias detectadas

### RF04 - Dashboard Textual
Gerar dashboard em tempo real mostrando:
- Status atual de cada projeto
- Hist√≥rico de m√©tricas (√∫ltimas 10 medi√ß√µes)
- Alertas ativos
- Tend√™ncias identificadas

### RF05 - Relat√≥rios Peri√≥dicos
Gerar relat√≥rios autom√°ticos:
- **Di√°rio:** Resumo de atividades e alertas
- **Semanal:** An√°lise de tend√™ncias e recomenda√ß√µes
- **Mensal:** Comparativo entre projetos e benchmarks

## Arquitetura do Sistema

```python
"""
metrics_monitor.py

Sistema de monitoramento cont√≠nuo de m√©tricas de teste.
Coleta dados, detecta anomalias e gera alertas automaticamente.
"""

from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import json
import statistics

class AlertLevel(Enum):
    """N√≠veis de alerta do sistema."""
    CRITICAL = "üî¥ CR√çTICO"
    WARNING = "üü° ATEN√á√ÉO"  
    INFO = "üîµ INFO"

class TrendType(Enum):
    """Tipos de tend√™ncia detectados."""
    IMPROVING = "melhorando"
    STABLE = "est√°vel"
    DEGRADING = "degradando"
    VOLATILE = "vol√°til"

@dataclass
class MetricSnapshot:
    """Snapshot de uma m√©trica em um momento espec√≠fico."""
    timestamp: datetime
    value: float
    metadata: Dict = field(default_factory=dict)

@dataclass
class Alert:
    """Alerta gerado pelo sistema de monitoramento."""
    level: AlertLevel
    project: str
    metric: str
    message: str
    timestamp: datetime
    current_value: float
    threshold_value: Optional[float] = None
    recommendation: Optional[str] = None

@dataclass
class ProjectMetrics:
    """Conjunto de m√©tricas para um projeto espec√≠fico."""
    project_name: str
    coverage_line: List[MetricSnapshot]
    coverage_branch: List[MetricSnapshot]
    defect_density: List[MetricSnapshot]
    mttd: List[MetricSnapshot]
    discovery_rate: List[MetricSnapshot]
    test_performance: List[MetricSnapshot]
    last_updated: datetime

class MetricsCollector:
    """
    Simulador de coleta de m√©tricas para desenvolvimento.
    Em produ√ß√£o, integraria com ferramentas reais.
    """
    
    def __init__(self):
        """Inicializa coletor com configura√ß√µes base."""
        self.simulation_variance = 0.05  # 5% de varia√ß√£o simulada
        
    def collect_project_metrics(self, project_name: str, 
                               base_values: Dict[str, float]) -> Dict[str, float]:
        """
        Simula coleta de m√©tricas com varia√ß√£o real√≠stica.
        
        Args:
            project_name: Nome do projeto
            base_values: Valores base para simula√ß√£o
            
        Returns:
            Dict com m√©tricas coletadas
        """
        # TODO: Implementar simula√ß√£o real√≠stica de coleta
        pass
    
    def _add_realistic_variance(self, base_value: float, 
                               metric_type: str) -> float:
        """
        Adiciona varia√ß√£o real√≠stica baseada no tipo de m√©trica.
        
        Args:
            base_value: Valor base da m√©trica
            metric_type: Tipo de m√©trica para varia√ß√£o apropriada
            
        Returns:
            Valor com varia√ß√£o aplicada
        """
        # TODO: Implementar varia√ß√£o por tipo de m√©trica
        pass

class AnomalyDetector:
    """
    Detector de anomalias e tend√™ncias em m√©tricas.
    Usa an√°lise estat√≠stica simples para identificar padr√µes.
    """
    
    def __init__(self, min_data_points: int = 5):
        """
        Inicializa detector com par√¢metros de an√°lise.
        
        Args:
            min_data_points: M√≠nimo de pontos para an√°lise de tend√™ncia
        """
        self.min_data_points = min_data_points
        self.anomaly_threshold = 2.0  # Desvios padr√£o para anomalia
        
    def detect_anomalies(self, snapshots: List[MetricSnapshot],
                        metric_name: str) -> List[Alert]:
        """
        Detecta anomalias em uma s√©rie temporal de m√©tricas.
        
        Args:
            snapshots: Lista de snapshots hist√≥ricos
            metric_name: Nome da m√©trica sendo analisada
            
        Returns:
            Lista de alertas gerados
        """
        # TODO: Implementar detec√ß√£o de anomalias
        pass
    
    def analyze_trend(self, snapshots: List[MetricSnapshot]) -> TrendType:
        """
        Analisa tend√™ncia geral dos dados.
        
        Args:
            snapshots: Lista de snapshots para an√°lise
            
        Returns:
            TrendType identificado
        """
        # TODO: Implementar an√°lise de tend√™ncia
        pass
    
    def _detect_sudden_degradation(self, snapshots: List[MetricSnapshot]) -> bool:
        """
        Detecta degrada√ß√£o s√∫bita (>10% queda entre medi√ß√µes consecutivas).
        
        Args:
            snapshots: Lista de snapshots para an√°lise
            
        Returns:
            True se degrada√ß√£o s√∫bita for detectada
        """
        # TODO: Implementar detec√ß√£o de degrada√ß√£o s√∫bita
        pass
    
    def _detect_threshold_violation(self, current_value: float,
                                  threshold: float,
                                  operator: str) -> bool:
        """
        Detecta viola√ß√£o de threshold configurado.
        
        Args:
            current_value: Valor atual da m√©trica
            threshold: Valor limite configurado
            operator: Operador de compara√ß√£o (>=, <=, etc.)
            
        Returns:
            True se viola√ß√£o for detectada
        """
        # TODO: Implementar detec√ß√£o de viola√ß√£o
        pass

class MetricsMonitor:
    """
    Sistema principal de monitoramento de m√©tricas.
    Orquestra coleta, an√°lise e gera√ß√£o de alertas.
    """
    
    def __init__(self):
        """Inicializa sistema de monitoramento."""
        self.projects: Dict[str, ProjectMetrics] = {}
        self.collector = MetricsCollector()
        self.detector = AnomalyDetector()
        self.thresholds = self._load_default_thresholds()
        self.active_alerts: List[Alert] = []
        
    def register_project(self, project_name: str, 
                        initial_config: Dict[str, float]) -> None:
        """
        Registra novo projeto para monitoramento.
        
        Args:
            project_name: Nome do projeto
            initial_config: Configura√ß√£o inicial e valores base
        """
        # TODO: Implementar registro de projeto
        pass
    
    def update_project_metrics(self, project_name: str) -> List[Alert]:
        """
        Atualiza m√©tricas de um projeto e detecta anomalias.
        
        Args:
            project_name: Nome do projeto a ser atualizado
            
        Returns:
            Lista de novos alertas gerados
        """
        # TODO: Implementar atualiza√ß√£o e an√°lise
        pass
    
    def get_project_status(self, project_name: str) -> Dict:
        """
        Retorna status atual completo de um projeto.
        
        Args:
            project_name: Nome do projeto
            
        Returns:
            Dict com status detalhado
        """
        # TODO: Implementar gera√ß√£o de status
        pass
    
    def generate_dashboard(self) -> str:
        """
        Gera dashboard textual com status de todos os projetos.
        
        Returns:
            Dashboard formatado em texto
        """
        # TODO: Implementar gera√ß√£o de dashboard
        pass
    
    def generate_daily_report(self) -> str:
        """
        Gera relat√≥rio di√°rio de atividades.
        
        Returns:
            Relat√≥rio formatado
        """
        # TODO: Implementar relat√≥rio di√°rio
        pass
    
    def _load_default_thresholds(self) -> Dict[str, Dict]:
        """
        Carrega thresholds padr√£o para detec√ß√£o de anomalias.
        
        Returns:
            Dict com thresholds por m√©trica
        """
        return {
            "coverage_line": {"min": 80.0, "critical": 70.0},
            "coverage_branch": {"min": 75.0, "critical": 65.0},
            "defect_density": {"max": 5.0, "critical": 10.0},
            "mttd": {"max": 7.0, "critical": 14.0},  # dias
            "discovery_rate": {"min": 0.5, "max": 10.0},  # defeitos/dia
            "test_performance": {"max": 300.0, "critical": 600.0}  # segundos
        }

# Configura√ß√£o dos projetos simulados
PROJECTS_CONFIG = {
    "E-commerce": {
        "coverage_line": 85.0,
        "coverage_branch": 78.0, 
        "defect_density": 3.2,
        "mttd": 4.5,
        "discovery_rate": 2.1,
        "test_performance": 180.0
    },
    "Mobile App": {
        "coverage_line": 72.0,
        "coverage_branch": 68.0,
        "defect_density": 4.8,
        "mttd": 6.2,
        "discovery_rate": 3.4,
        "test_performance": 95.0
    },
    "API Gateway": {
        "coverage_line": 92.0,
        "coverage_branch": 89.0,
        "defect_density": 1.8,
        "mttd": 2.1,
        "discovery_rate": 1.2,
        "test_performance": 45.0
    }
}

def main():
    """Fun√ß√£o principal que demonstra o sistema de monitoramento."""
    monitor = MetricsMonitor()
    
    print("=== SISTEMA DE MONITORAMENTO DE M√âTRICAS ===")
    print()
    
    # Registrar projetos
    for project_name, config in PROJECTS_CONFIG.items():
        monitor.register_project(project_name, config)
        print(f"‚úì Projeto '{project_name}' registrado para monitoramento")
    
    print()
    print("üîÑ Iniciando simula√ß√£o de monitoramento...")
    print()
    
    # TODO: Simular 24 horas de monitoramento com coletas peri√≥dicas
    # for hour in range(24):
    #     print(f"--- Hora {hour:02d}:00 ---")
    #     
    #     for project_name in PROJECTS_CONFIG.keys():
    #         alerts = monitor.update_project_metrics(project_name)
    #         if alerts:
    #             for alert in alerts:
    #                 print(f"{alert.level.value}: {alert.message}")
    #     
    #     # Exibir dashboard a cada 6 horas
    #     if hour % 6 == 0:
    #         print("\nüìä DASHBOARD ATUAL:")
    #         print(monitor.generate_dashboard())
    
    # TODO: Gerar relat√≥rio final
    # print("\nüìã RELAT√ìRIO DI√ÅRIO:")
    # print(monitor.generate_daily_report())

if __name__ == "__main__":
    main()
```

## Tarefas Espec√≠ficas

### Tarefa 1: Implementa√ß√£o da Coleta Simulada
Crie simula√ß√£o real√≠stica que:
- Varie m√©tricas de forma coerente (cobertura n√£o muda drasticamente)
- Introduza ocasionalmente "eventos" (picos de defeitos, degrada√ß√£o)
- Mantenha padr√µes consistentes com o tipo de projeto

### Tarefa 2: Detec√ß√£o de Anomalias
Implemente algoritmos para detectar:
- **Anomalias estat√≠sticas** (valores fora de 2 desvios padr√£o)
- **Tend√™ncias negativas** (regress√£o linear com slope negativo)
- **Viola√ß√µes de threshold** (valores absolutos cr√≠ticos)
- **Variabilidade excessiva** (coeficiente de varia√ß√£o alto)

### Tarefa 3: Sistema de Alertas Inteligente
Desenvolva sistema que:
- **Priorize alertas** por criticidade e impacto
- **Evite spam** (n√£o alerte repetidamente pelo mesmo problema)
- **Forne√ßa contexto** (tend√™ncia hist√≥rica, compara√ß√£o com outros projetos)
- **Sugira a√ß√µes** espec√≠ficas para cada tipo de problema

### Tarefa 4: Dashboard Informativo
Crie dashboard que mostre:
- **Status visual** de cada projeto (üü¢üü°üî¥)
- **M√©tricas atuais** vs. targets
- **Alertas ativos** organizados por prioridade
- **Tend√™ncias recentes** (√∫ltimas 5 medi√ß√µes)

## Cen√°rios de Teste

### Cen√°rio 1: Degrada√ß√£o Gradual
Simule projeto onde cobertura diminui gradualmente de 85% para 75% ao longo de 12 horas.
**Resultado esperado:** Alerta de tend√™ncia negativa ap√≥s 3-4 medi√ß√µes consecutivas.

### Cen√°rio 2: Pico de Defeitos
Simule descoberta s√∫bita de 8 defeitos em uma medi√ß√£o (vs. m√©dia de 2).
**Resultado esperado:** Alerta cr√≠tico de anomalia estat√≠stica.

### Cen√°rio 3: Melhoria Consistente
Simule projeto com melhoria constante em todas as m√©tricas.
**Resultado esperado:** Alertas informativos de marcos atingidos.

### Cen√°rio 4: Estabilidade com Ru√≠do
Simule m√©tricas est√°veis com varia√ß√£o normal (¬±2%).
**Resultado esperado:** Nenhum alerta, status est√°vel.

## Crit√©rios de Avalia√ß√£o

| Aspecto | Excelente (4) | Bom (3) | Satisfat√≥rio (2) | Insuficiente (1) |
|---------|---------------|---------|------------------|------------------|
| **Arquitetura do Sistema** | Bem estruturado, extens√≠vel e modular | Estrutura clara e funcional | Estrutura b√°sica adequada | Estrutura confusa ou monol√≠tica |
| **Detec√ß√£o de Anomalias** | Algoritmos robustos e configur√°veis | Detec√ß√£o efetiva com alguns gaps | Detec√ß√£o b√°sica funcional | Detec√ß√£o inadequada ou incorreta |
| **Sistema de Alertas** | Alertas inteligentes e acion√°veis | Alertas √∫teis e bem categorizados | Alertas b√°sicos funcionais | Alertas confusos ou irrelevantes |
| **Dashboard e Relat√≥rios** | Interface clara e informativa | Apresenta√ß√£o adequada | Informa√ß√£o b√°sica organizada | Apresenta√ß√£o pobre ou confusa |

## Dicas de Implementa√ß√£o

üí° **Comece simples:** Implemente funcionalidade b√°sica antes de adicionar sofistica√ß√£o  

üí° **Use estat√≠sticas:** Aproveite o m√≥dulo `statistics` para c√°lculos de tend√™ncia  

üí° **Estado persistente:** Mantenha hist√≥rico das m√©tricas para an√°lise temporal  

üí° **Configurabilidade:** Permita ajustar thresholds e par√¢metros de detec√ß√£o  

üí° **Testes incrementais:** Teste cada componente separadamente primeiro  

## Entreg√°veis

1. **`metrics_monitor.py`** - Sistema completo de monitoramento
2. **`simulation_results.txt`** - Log de 24h de simula√ß√£o mostrando alertas
3. **`dashboard_samples.txt`** - Exemplos de dashboard em diferentes momentos
4. **`architecture_doc.md`** - Documenta√ß√£o da arquitetura e decis√µes de design
5. **`reflexao.md`** - Reflex√£o sobre:
   - Desafios de detec√ß√£o autom√°tica de anomalias
   - Balanceamento entre sensibilidade e ru√≠do
   - Aplicabilidade em ambientes reais

## Extens√µes Opcionais (B√¥nus)

üéØ **Persist√™ncia em JSON:** Salve e carregue estado do sistema  
üéØ **Configura√ß√£o externa:** Leia thresholds de arquivo de configura√ß√£o  
üéØ **Correla√ß√£o entre m√©tricas:** Detecte quando m√∫ltiplas m√©tricas degradam juntas  
üéØ **Previs√£o simples:** Use tend√™ncias para prever valores futuros  
üéØ **Exporta√ß√£o de relat√≥rios:** Gere relat√≥rios em formato JSON estruturado  

## Quest√µes para Reflex√£o

ü§î **Como balancear sensibilidade vs. ru√≠do em alertas automatizados?**

ü§î **Quais m√©tricas s√£o mais importantes para monitoramento cont√≠nuo?**

ü§î **Como adaptar thresholds para diferentes tipos de projeto?**

ü§î **Que outros tipos de anomalias poderiam ser detectados?**

ü§î **Como este sistema poderia integrar com ferramentas reais de CI/CD?**

---

**Foque na utilidade pr√°tica e na redu√ß√£o de ru√≠do nos alertas!** üìä
